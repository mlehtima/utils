#!/bin/bash

script_version=4

PRINT_RED='\033[0;31m'
PRINT_GREEN='\033[0;32m'
PRINT_NC='\033[0m'

OPT_FORMAT_DEFAULT="\$0"
OPT_SCAN_FULL="%s%n%b"
OPT_SCAN_SUBJECT="%s"
OPT_SCAN_REGEX_TAG="^\[.*\].*"
OPT_SCAN_REGEX_ALL=".*"
PER_REPOSITORY_CONFIG=".git/update-submodule.conf"

opt_force_branch=0
opt_force_remote=0
opt_force_submodule=0
opt_branch=master
opt_remote=origin
opt_submodule=
opt_scan="$OPT_SCAN_FULL"
opt_scan_regex="$OPT_SCAN_REGEX_TAG"
opt_reverse=
opt_signoff=
opt_format="$OPT_FORMAT_DEFAULT"
all_good=1

print_error() {
    echo -e "${PRINT_RED}$@${PRINT_NC}"
}

print_debug() {
    if [ "$DEBUG" == "1" ]; then
        echo -e "${PRINT_GREEN}$@${PRINT_NC}" >&2
    fi
}

print_normal() {
    echo -e "${PRINT_GREEN}$@${PRINT_NC}" >&1
}

run_cmd() {
    print_debug "$ $@"
    "$@"
}

check_bin() {
    while [ $# -gt 0 ]; do
        which "$1" 1>/dev/null 2>&1
        if [ ! $? -eq 0 ]; then
            print_error "$1 not found in \$PATH"
            all_good=0
        fi
        shift
    done
}

enter_dir() {
    print_debug "# Enter $1"
    pushd "$1" 1>/dev/null 2>&1
}

leave_dir() {
    print_debug "# Leave $1"
    popd 1>/dev/null 2>&1
}

handle_repository() {
    local submodule_name=
    local force_remote="$1"     ; shift
    local use_remote="$1"       ; shift
    local force_branch="$1"     ; shift
    local use_branch="$1"       ; shift
    local force_submodule="$1"  ; shift
    if [ $force_submodule -eq 1 ]; then
        submodule_name="$1"
        shift
    fi
    local repository="$@"
    local old_sha1=
    local new_sha1=
    local lines_changed=
    local current_branch=
    local update_branch=

    if [ ! -d "$repository" ]; then
        print_error "Skipping $repository (dir doesn't exist?)"
        return
    fi

    if [ ! -d "$repository"/.git ]; then
        print_error "Skipping $repository (dir is not git repo?)"
        return
    fi

    enter_dir "$repository"

        if [ -f "$PER_REPOSITORY_CONFIG" ]; then
            source "$PER_REPOSITORY_CONFIG"
            if [[ $force_remote -eq 0 && -n "$REMOTE" ]]; then
                print_normal "Use remote $REMOTE from repository configuration."
                use_remote=$REMOTE
            fi
            if [[ $force_branch -eq 0 && -n "$BRANCH" ]]; then
                print_normal "Use branch $BRANCH from repository configuration."
                use_branch=$BRANCH
            fi
            if [[ $force_submodule -eq 0 && -n "$SUBMODULE" ]]; then
                print_normal "Use submodule $SUBMODULE from repository configuration."
                submodule_name=$SUBMODULE
            fi

            unset REMOTE
            unset BRANCH
            unset SUBMODULE
        fi

        if [ -z "$submodule_name" ]; then
            if [ $(git submodule | wc -l) -gt 1 ]; then
                print_error "Skipping $repository (multiple submodules)"
                leave_dir "$repository"
                return
            fi
            submodule_name="$(git submodule | awk '{ print $2 }')"
        else
            submodule_name="$(git submodule | awk '{ print $2 }' | grep $submodule_name)"
        fi

        if [ -z "$submodule_name" ]; then
            print_error "Skipping $repository (submodule is not initialized)"
            leave_dir "$repository"
            return
        fi

        # Both main repo and submodule are handled
        lines_changed="$(git diff | wc -l)"
        if [ "$lines_changed" -gt 0 ]; then
            print_error "$repository contains local changes, skipping."
            leave_dir "$repository"
            return
        fi

        current_branch="$(git branch | grep -e '^\*' | awk '{ print $2 }')"
        update_branch="update_submodule_$(date +%s)"

        # Make sure we are in latest commit
        run_cmd git fetch $use_remote
        run_cmd git checkout remotes/$use_remote/$use_branch -b $update_branch
        if [ ! $? -eq 0 ]; then
            print_error "Cannot switch to $update_branch (tracking remotes/$use_remote/$use_branch)"
            leave_dir "$repository"
            return
        fi
        run_cmd git submodule update

        old_sha1="$(git submodule | awk '{ print $1 }')"
        print_debug "# Old sha1: $old_sha1"

        enter_dir "$submodule_name"

            temp_tag="update_submodule_$(date +%s)"
            temp_commit="$(mktemp)"
            run_cmd git fetch origin
            run_cmd git tag $temp_tag
            run_cmd git checkout master
            run_cmd git merge origin/master
            echo "REMOVE THIS LINE! (this commit is for $repository)" >> "$temp_commit"
            echo -e "Update submodule.\n" >> "$temp_commit"
            # This is the beef, create comment lines from submodule commits
            if [[ -n "$opt_scan" && -n "$opt_scan_regex" ]]; then
                run_cmd git log --format="$opt_scan" --no-merges $opt_reverse ${temp_tag}.. | grep -e "$opt_scan_regex" | awk "{ print $opt_format }" >> "$temp_commit"
            fi
            run_cmd git tag -d $temp_tag

        leave_dir "$submodule_name"

        new_sha1="$(git submodule | awk '{ print $1 }')"
        print_debug "# New sha1: $new_sha1"

        if [ "$old_sha1" == "$new_sha1" ]; then
            print_normal "No changes in $repository submodule."
            rm -f "$temp_commit"
            run_cmd git checkout $current_branch
            run_cmd git submodule update
            run_cmd git branch -D $update_branch
            leave_dir "$repository"
            return
        fi

        run_cmd git add $submodule_name
        run_cmd git commit $opt_signoff -t "$temp_commit"
        rm -f "$temp_commit"

    leave_dir "$repository"
}

check_bin git mktemp awk grep sed
if [ ! $all_good -eq 1 ]; then
    echo "Required bits missing. Abort."
    exit 1
fi

print_help() {
    echo "Usage: $(basename $0) [OPTION] <repositories>"
    echo ""
    echo "Update droid-{hal,configs}-device (repository with submodule) style repositories'"
    echo "submodule to latest upstream and generate changelog for the submodule update"
    echo "commit. Defaults for BRANCH, REMOTE and SUBMODULE can be set per-repository"
    echo "with $PER_REPOSITORY_CONFIG."
    echo ""
    echo "All switches affect repositories given after the switch, and when explicitly set"
    echo "override whatever is defined in per-repository configuration file. That means"
    echo "single command line may have multiple switches for different repositories."
    echo ""
    echo "  -h, --help      This help."
    echo "  -v, --verbose   Print all commands and additional debugs."
    echo "  -b, --branch    What remote to use for updates (default $opt_remote)."
    echo "  -r, --remote    What branch to use for updates (default $opt_branch)."
    echo "  -s, --submodule Set explicit submodule name, useful if repository contains"
    echo "                    multiple submodules."
    echo "  --use-subject   Take only subject lines from submodule commits to the update"
    echo "                    commit message."
    echo "  --scan          What to scan from commit messages (see git log --format)"
    echo "                    default: $opt_scan"
    echo "  --match         Matching lines are added to the update commit message."
    echo "                    default: $opt_scan_regex"
    echo "  --reverse       Reverse matched lines in update commit message."
    echo "  --format        How to format message lines, see awk print (default $opt_format)."
    echo "  --signoff       Add Signed-off-by line by the committer at the end of the"
    echo "                    commit log message."
    echo ""
}

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            print_help
            exit 0
            ;;
        --version)
            echo "$(basename $0) v$script_version"
            exit 0
            ;;
        -v|--verbose)
            DEBUG=1
            ;;
        -b|--branch)
            shift
            opt_branch=$1
            opt_force_branch=1
            print_normal "Setting branch to $opt_branch for future updates."
            ;;
        -r|--remote)
            shift
            opt_remote=$1
            opt_force_remote=1
            print_normal "Setting remote to $opt_remote for future updates."
            ;;
        -s|--submodule)
            shift
            opt_submodule=$1
            opt_force_submodule=1
            print_normal "Setting explicit submodule to $opt_submodule for future updates."
            ;;
        --use-subject)
            opt_scan="$OPT_SCAN_SUBJECT"
            opt_scan_regex="$OPT_SCAN_REGEX_ALL"
            ;;
        --scan)
            shift
            opt_scan="$1"
            ;;
        --match)
            shift
            opt_scan_regex="$1"
            ;;
        --reverse)
            shift
            opt_reverse="--reverse"
            ;;
        --format)
            shift
            opt_format="$1"
            ;;
        --signoff)
            opt_signoff="--signoff"
            ;;
        --autocomplete)
            echo "-h --help -v --verbose --version -b --branch -r --remote -s --submodule --use-subject --scan --match --reverse --format --signoff"
            exit 0
            ;;
        -*)
            echo "Unknown switch '$1'"
            exit 1
            ;;
        *)
            print_debug "# Repository $1 remote $opt_remote($opt_force_remote) branch $opt_branch($opt_force_branch) submodule $opt_submodule($opt_force_submodule)"
            handle_repository $opt_force_remote $opt_remote $opt_force_branch $opt_branch $opt_force_submodule $opt_submodule "$1"
            ;;
    esac
    shift
done
