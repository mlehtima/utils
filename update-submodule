#!/bin/bash

script_version=3

PRINT_RED='\033[0;31m'
PRINT_GREEN='\033[0;32m'
PRINT_NC='\033[0m'

opt_force_branch=0
opt_force_remote=0
opt_force_submodule=0
opt_branch=master
opt_remote=origin
opt_submodule=
opt_signoff=
all_good=1

print_error() {
    echo -e "${PRINT_RED}$@${PRINT_NC}"
}

print_debug() {
    if [ "$DEBUG" == "1" ]; then
        echo -e "${PRINT_GREEN}$@${PRINT_NC}" >&2
    fi
}

print_normal() {
    echo -e "${PRINT_GREEN}$@${PRINT_NC}" >&1
}

run_cmd() {
    print_debug "$ $@"
    $@
}

check_bin() {
    while [ $# -gt 0 ]; do
        which "$1" 1>/dev/null 2>&1
        if [ ! $? -eq 0 ]; then
            print_error "$1 not found in \$PATH"
            all_good=0
        fi
        shift
    done
}

enter_dir() {
    print_debug "# Enter $1"
    pushd "$1" 1>/dev/null 2>&1
}

leave_dir() {
    print_debug "# Leave $1"
    popd 1>/dev/null 2>&1
}

handle_repository() {
    local submodule_name=
    local force_remote="$1"     ; shift
    local use_remote="$1"       ; shift
    local force_branch="$1"     ; shift
    local use_branch="$1"       ; shift
    local force_submodule="$1"  ; shift
    if [ $force_submodule -eq 1 ]; then
        submodule_name="$1"
        shift
    fi
    local repository="$@"
    local old_sha1=
    local new_sha1=
    local lines_changed=
    local current_branch=
    local update_branch=

    if [ ! -d "$repository" ]; then
        print_error "Skipping $repository (dir doesn't exist?)"
        return
    fi

    if [ ! -d "$repository"/.git ]; then
        print_error "Skipping $repository (dir is not git repo?)"
        return
    fi

    enter_dir "$repository"

        if [ -f ".git/update-submodule.conf" ]; then
            source ".git/update-submodule.conf"
            if [[ $force_remote -eq 0 && -n "$REMOTE" ]]; then
                print_normal "Use remote $REMOTE from repository configuration."
                use_remote=$REMOTE
            fi
            if [[ $force_branch -eq 0 && -n "$BRANCH" ]]; then
                print_normal "Use branch $BRANCH from repository configuration."
                use_branch=$BRANCH
            fi
            if [[ $force_submodule -eq 0 && -n "$SUBMODULE" ]]; then
                print_normal "Use submodule $SUBMODULE from repository configuration."
                submodule_name=$SUBMODULE
            fi
        fi

        unset REMOTE
        unset BRANCH
        unset SUBMODULE

        if [ -z "$submodule_name" ]; then
            if [ $(git submodule | wc -l) -gt 1 ]; then
                print_error "Skipping $repository (multiple submodules)"
                leave_dir "$repository"
                return
            fi
            submodule_name="$(git submodule | awk '{ print $2 }')"
        else
            submodule_name="$(git submodule | awk '{ print $2 }' | grep $submodule_name)"
        fi

        if [ -z "$submodule_name" ]; then
            print_error "Skipping $repository (submodule is not initialized)"
            leave_dir "$repository"
            return
        fi

        # Both main repo and submodule are handled
        lines_changed="$(git diff | wc -l)"
        if [ "$lines_changed" -gt 0 ]; then
            print_error "$repository contains local changes, skipping."
            leave_dir "$repository"
            return
        fi

        current_branch="$(git branch | grep -e '^\*' | awk '{ print $2 }')"
        update_branch="update_submodule_$(date +%s)"

        # Make sure we are in latest commit
        run_cmd git fetch $use_remote
        run_cmd git checkout remotes/$use_remote/$use_branch -b $update_branch
        if [ ! $? -eq 0 ]; then
            print_error "Cannot switch to $update_branch (tracking remotes/$use_remote/$use_branch)"
            leave_dir "$repository"
            return
        fi
        run_cmd git submodule update

        old_sha1="$(git submodule | awk '{ print $1 }')"
        print_debug "# Old sha1: $old_sha1"

        enter_dir "$submodule_name"

            temp_tag="update_submodule_$(date +%s)"
            temp_commit="$(mktemp)"
            run_cmd git fetch origin
            run_cmd git tag $temp_tag
            run_cmd git checkout master
            run_cmd git merge origin/master
            echo "REMOVE THIS LINE! (this commit is for $repository)" >> "$temp_commit"
            echo -e "Update submodule.\n" >> "$temp_commit"
            # This is the beef, create comment lines from submodule commits
            run_cmd git log --no-merges --reverse ${temp_tag}.. | grep -e '\[.*\].*' | sed -e 's/^[ \t]*//' >> "$temp_commit"
            run_cmd git tag -d $temp_tag

        leave_dir "$submodule_name"

        new_sha1="$(git submodule | awk '{ print $1 }')"
        print_debug "# New sha1: $new_sha1"

        if [ "$old_sha1" == "$new_sha1" ]; then
            print_normal "No changes in $repository submodule."
            rm -f "$temp_commit"
            run_cmd git checkout $current_branch
            run_cmd git submodule update
            run_cmd git branch -D $update_branch
            leave_dir "$repository"
            return
        fi

        run_cmd git add $submodule_name
        run_cmd git commit $opt_signoff -t "$temp_commit"
        rm -f "$temp_commit"

    leave_dir "$repository"
}

check_bin git mktemp awk grep sed
if [ ! $all_good -eq 1 ]; then
    echo "Required bits missing. Abort."
    exit 1
fi

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            echo "Usage: $(basename $0) [OPTION] <repositories>"
            echo ""
            echo "Update droid-{hal,configs}-device (repository with submodule) style repositories'"
            echo "submodule to latest upstream and generate changelog for the submodule update"
            echo "commit."
            echo ""
            echo "  -h, --help      This help."
            echo "  -b, --branch    Set main remote for updates."
            echo "  -r, --remote    Set main branch for updates."
            echo "                    These switches set the branch or remote to the value for"
            echo "                    all updates after. For example:"
            echo "                      $(basename $0) dev1 -b devel dev2"
            echo "                    would handle dev1 update against branch master and dev2"
            echo "                    update against branch devel."
            echo "  -s, --submodule Set explicit submodule name, useful if repository contains"
            echo "                    multiple submodules."
            echo "  --signoff       Add Signed-off-by line by the committer at the end of the"
            echo "                    commit log message."
            echo ""
            echo "                    Defaults: remote=$opt_remote branch=$opt_branch"
            echo ""
            exit 0
            ;;
        --version)
            echo "$(basename $0) v$script_version"
            exit 0
            ;;
        -v|--verbose)
            DEBUG=1
            ;;
        -b|--branch)
            shift
            opt_branch=$1
            opt_force_branch=1
            print_normal "Setting branch to $opt_branch for future updates."
            ;;
        -r|--remote)
            shift
            opt_remote=$1
            opt_force_remote=1
            print_normal "Setting remote to $opt_remote for future updates."
            ;;
        -s|--submodule)
            shift
            opt_submodule=$1
            opt_force_submodule=1
            print_normal "Setting explicit submodule to $opt_submodule for future updates."
            ;;
        --signoff)
            opt_signoff="--signoff"
            ;;
        --autocomplete)
            echo "-h --help -v --verbose --version -b --branch -r --remote --signoff"
            exit 0
            ;;
        -*)
            echo "Unknown switch '$1'"
            exit 1
            ;;
        *)
            print_debug "# Repository $1 remote $opt_remote($opt_force_remote) branch $opt_branch($opt_force_branch) submodule $opt_submodule($opt_force_submodule)"
            handle_repository $opt_force_remote $opt_remote $opt_force_branch $opt_branch $opt_force_submodule $opt_submodule "$1"
            ;;
    esac
    shift
done
