#!/bin/bash

script_version=7

SCRIPTPATH="$(dirname "`readlink -f $0`")"
source "$SCRIPTPATH/update-common.sh" || exit 1

OPT_SUBJECT_DEFAULT="%s: Update submodule."
OPT_FORMAT_DEFAULT="\$0"
OPT_SCAN_FULL="%s%n%b"
OPT_SCAN_SUBJECT="%s"
OPT_SCAN_REGEX_TAG="^\[.*\].*"
OPT_SCAN_REGEX_ALL=".*"
GLOBAL_CONFIG="$HOME/.config/update-submodule.conf"
PER_REPOSITORY_CONFIG=".git/update-submodule.conf"

# Can be set from global configuration
OPT_SIGNOFF=

opt_force_branch=0
opt_force_remote=0
opt_force_subject=0
opt_force_submodule=0
opt_branch=master
opt_remote=origin
opt_subject="$OPT_SUBJECT_DEFAULT"
opt_submodule=
opt_scan="$OPT_SCAN_FULL"
opt_scan_regex="$OPT_SCAN_REGEX_TAG"
opt_reverse=
opt_format="$OPT_FORMAT_DEFAULT"
all_good=1

handle_repository() {
    local submodule_name=
    local force_remote="$1"     ; shift
    local use_remote="$1"       ; shift
    local force_branch="$1"     ; shift
    local use_branch="$1"       ; shift
    local force_subject="$1"    ; shift
    local use_subject="$1"      ; shift
    local force_submodule="$1"  ; shift
    if [ $force_submodule -eq 1 ]; then
        submodule_name="$1"
        shift
    fi
    local repository="$@"
    local old_sha1=
    local new_sha1=
    local lines_changed=
    local current_branch=
    local update_branch=
    local subject_line=
    local temp_tag=
    local temp_commit=
    local _signoff=

    if [ ! -d "$repository" ]; then
        print_error "Skipping $repository (dir doesn't exist?)"
        return
    fi

    if [ ! -d "$repository"/.git ]; then
        print_error "Skipping $repository (dir is not git repo?)"
        return
    fi

    enter_dir "$repository"

        if [ -f "$PER_REPOSITORY_CONFIG" ]; then
            source "$PER_REPOSITORY_CONFIG"
            if [[ $force_remote -eq 0 && -n "$REMOTE" ]]; then
                print_normal "Use remote $REMOTE from repository configuration."
                use_remote=$REMOTE
            fi
            if [[ $force_branch -eq 0 && -n "$BRANCH" ]]; then
                print_normal "Use branch $BRANCH from repository configuration."
                use_branch=$BRANCH
            fi
            if [[ $force_submodule -eq 0 && -n "$SUBMODULE" ]]; then
                print_normal "Use submodule $SUBMODULE from repository configuration."
                submodule_name=$SUBMODULE
            fi
            if [[ $force_subject -eq 0 && -n "$SUBJECT" ]]; then
                print_normal "Use subject '$SUBJECT' from repository configuration."
                use_subject=$SUBJECT
            fi

            unset REMOTE
            unset BRANCH
            unset SUBJECT
            unset SUBMODULE
        fi

        if [ -z "$submodule_name" ]; then
            if [ $(git submodule | wc -l) -gt 1 ]; then
                print_error "Skipping $repository (multiple submodules)"
                leave_dir "$repository"
                return
            fi
            submodule_name="$(git submodule | awk '{ print $2 }')"
        else
            submodule_name="$(git submodule | awk '{ print $2 }' | grep $submodule_name)"
        fi

        if [ -z "$submodule_name" ]; then
            print_error "Skipping $repository (submodule is not initialized)"
            leave_dir "$repository"
            return
        fi

        # Both main repo and submodule are handled
        lines_changed="$(git diff | wc -l)"
        if [ "$lines_changed" -gt 0 ]; then
            print_error "$repository contains local changes, skipping."
            leave_dir "$repository"
            return
        fi

        current_branch="$(git branch | grep -e '^\*' | awk '{ print $2 }')"
        update_branch="update_submodule_$(date +%s)"

        # Make sure we are in latest commit
        run_cmd git fetch $use_remote
        run_cmd git checkout remotes/$use_remote/$use_branch -b $update_branch
        if [ ! $? -eq 0 ]; then
            print_error "Cannot switch to $update_branch (tracking remotes/$use_remote/$use_branch)"
            leave_dir "$repository"
            return
        fi
        run_cmd git submodule update

        old_sha1="$(git submodule | cut -b2- | awk '{ print $1 }')"
        print_debug "# Old sha1: $old_sha1"

        enter_dir "$submodule_name"

            temp_tag="update_submodule_$(date +%s)"
            temp_commit="$(mktemp)"
            run_cmd git fetch origin
            run_cmd git tag $temp_tag
            run_cmd git checkout master
            run_cmd git merge origin/master
            echo "REMOVE THIS LINE! (this commit is for $repository)" >> "$temp_commit"
            subject_line="${use_subject//%s/$submodule_name}"
            subject_line="${subject_line//%r/`basename "$repository"`}"
            echo -e "$subject_line\n" >> "$temp_commit"
            # This is the beef, create comment lines from submodule commits
            if [[ -n "$opt_scan" && -n "$opt_scan_regex" ]]; then
                run_cmd git log --format="$opt_scan" --no-merges $opt_reverse ${temp_tag}.. | grep -e "$opt_scan_regex" | awk "{ print $opt_format }" >> "$temp_commit"
            fi
            run_cmd git tag -d $temp_tag

        leave_dir "$submodule_name"

        new_sha1="$(git submodule | cut -b2- | awk '{ print $1 }')"
        print_debug "# New sha1: $new_sha1"

        if [ "$old_sha1" == "$new_sha1" ]; then
            print_normal "No changes in $repository submodule."
            rm -f "$temp_commit"
            run_cmd git checkout $current_branch
            run_cmd git submodule update
            run_cmd git branch -D $update_branch
            leave_dir "$repository"
            return
        fi

        run_cmd git add $submodule_name
        if [ -n "$OPT_SIGNOFF" ]; then
            _signoff="--signoff"
        fi
        run_cmd git commit $_signoff -t "$temp_commit"
        rm -f "$temp_commit"

    leave_dir "$repository"
}

check_bin git mktemp awk grep sed

print_help() {
    echo "Usage: $(basename $0) [OPTION] <repositories>"
    echo ""
    echo "Update droid-{hal,configs}-device (repository with submodule) style repositories'"
    echo "submodule to latest upstream and generate changelog for the submodule update"
    echo "commit. Defaults for BRANCH, REMOTE, SUBMODULE and SUBJECT can be set per-repository"
    echo "with $PER_REPOSITORY_CONFIG."
    echo ""
    echo "All switches affect repositories given after the switch, and when explicitly set"
    echo "override whatever is defined in per-repository configuration file. That means"
    echo "single command line may have multiple switches for different repositories."
    echo ""
    echo "  -h, --help      This help."
    echo "  -v, --verbose   Print all commands and additional debugs."
    echo "  -r, --remote    What remote to use for updates (default $opt_remote)."
    echo "  -b, --branch    What branch to use for updates (default $opt_branch)."
    echo "  -s, --submodule Set explicit submodule name, useful if repository contains"
    echo "                    multiple submodules."
    echo "  --subject       Set custom subject line. Subject line string accepts some"
    echo "                    placeholders (%s submodule name, %r repository path)."
    echo "                    default: '%s: Update submodule.'"
    echo "  --use-subject   Take only subject lines from submodule commits to the update"
    echo "                    commit message."
    echo "  --scan          What to scan from commit messages (see git log --format)"
    echo "                    default: $opt_scan"
    echo "  --match         Matching lines are added to the update commit message."
    echo "                    default: $opt_scan_regex"
    echo "  --reverse       Reverse matched lines in update commit message."
    echo "  --format        How to format message lines, see awk print (default $opt_format)."
    echo "  --signoff       Add Signed-off-by line by the committer at the end of the"
    echo "                    commit log message."
    echo ""
}

if [ -f "$GLOBAL_CONFIG" ]; then
    source "$GLOBAL_CONFIG"
    if [ -n "$REMOTE" ]; then
        opt_remote="$REMOTE"
    fi
    if [ -n "$BRANCH" ]; then
        opt_branch="$BRANCH"
    fi
    if [ -n "$SUBJECT" ]; then
        opt_subject="$SUBJECT"
    fi

    unset REMOTE
    unset BRANCH
    unset SUBJECT
    unset SUBMODULE
fi

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            print_help
            exit 0
            ;;
        --version)
            print_version
            exit 0
            ;;
        -v|--verbose)
            DEBUG=1
            ;;
        -b|--branch)
            shift
            opt_branch=$1
            opt_force_branch=1
            print_normal "Setting branch to $opt_branch for future updates."
            ;;
        -r|--remote)
            shift
            opt_remote=$1
            opt_force_remote=1
            print_normal "Setting remote to $opt_remote for future updates."
            ;;
        -s|--submodule)
            shift
            opt_submodule=$1
            opt_force_submodule=1
            print_normal "Setting explicit submodule to $opt_submodule for future updates."
            ;;
        --subject)
            shift
            opt_subject="$1"
            opt_force_subject=1
            print_normal "Setting subject to '$opt_subject' for future updates."
            ;;
        --use-subject)
            opt_scan="$OPT_SCAN_SUBJECT"
            opt_scan_regex="$OPT_SCAN_REGEX_ALL"
            ;;
        --scan)
            shift
            opt_scan="$1"
            ;;
        --match)
            shift
            opt_scan_regex="$1"
            ;;
        --reverse)
            shift
            opt_reverse="--reverse"
            ;;
        --format)
            shift
            opt_format="$1"
            ;;
        --signoff)
            OPT_SIGNOFF="1"
            ;;
        --autocomplete)
            echo "-h --help -v --verbose --version -b --branch -r --remote -s --submodule --subject --use-subject --scan --match --reverse --format --signoff"
            exit 0
            ;;
        -*)
            echo "Unknown switch '$1'"
            exit 1
            ;;
        *)
            print_debug "# Repository $1 remote $opt_remote($opt_force_remote) branch $opt_branch($opt_force_branch) submodule $opt_submodule($opt_force_submodule) subject '$opt_subject'($opt_force_subject)"
            handle_repository $opt_force_remote $opt_remote $opt_force_branch $opt_branch $opt_force_subject "$opt_subject" $opt_force_submodule $opt_submodule "$1"
            ;;
    esac
    shift
done
