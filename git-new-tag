#!/bin/bash

VERSION="1.1.0"
VERSION_DATE="04/11/2019"
GIT_NEW_TAG_MAN_PATH="/usr/local/share/man/man1"
TAG_MSG_MSG=
TAG_ANNOTATE=
NEW_PREFIX=

manpage_option() {
    local short=$1
    local long=$2
    local description=$3
    echo -e ".PP\n${short//-/\\-}, ${long//-/\\-}\n.RS 4\n${description//-/\\-}\n.RE"
}

_manpage() {
    echo ".TH GIT\-NEW\-TAG 1 \"$VERSION_DATE\" \"$VERSION\" \"Git Manual\""
    echo '
.SH NAME
git-new-tag \- Intelligent tag increase
.SH SYNOPSIS
.sp
.nf
\fIgit new-tag\fR [\-1] [\-2] [\-3] [\-4] [\-r] [\-g]
            [\-a] [\-m <msg>]
            [\-p <prefix]
.fi
.sp
.SH DESCRIPTION
.sp
Look for and increment latest tag in current branch and add new tag reference in \fBrefs/tags/\fR.
.SH OPTIONS'
manpage_option -a --annotate "Make an unsigned, annotated tag object."
manpage_option -m --msg "Use the given tag message (instead of prompting)\&. Implies \\\fB-a\\\fR."
manpage_option -1 --major "Increase major value."
manpage_option -2 --minor "Increase minor value."
manpage_option -3 --micro "Increase micro value."
manpage_option -4 --patch "Increase patch value."
manpage_option -r --release "Increase release value."
manpage_option -g --git "Increase git suffix."
manpage_option -p --prefix "Add or modify prefix for the tag."
echo '
.SH "SEE ALSO"
.sp
\fBgit-tag\fR(1)\&.
.SH GIT
.sp
External tool for the \fBgit\fR(1) suite
'
}

case $1 in
    --autocomplete)
        echo -e "--help\n-1\n--major\n-2\n--minor\n-3\n--micro\n-4\n--patch\n-g\n--git\n-m\n--message\n-a\n--annotate\n-p\n--prefix\n-r\n--relase"
        exit 0
        ;;
    --manpage)
        _manpage
        exit 0
        ;;
    --install-manpage)
        shift
        if [ -n "$1" ]; then
            GIT_NEW_TAG_MAN_PATH="$1"
        fi
        _manpage | gzip > /tmp/git-new-tag.1.gz
        install -v -D -m0644 /tmp/git-new-tag.1.gz "$GIT_NEW_TAG_MAN_PATH"/git-new-tag.1.gz
        rm -f /tmp/git-new-tag.1.gz
        exit 0
        ;;
esac

current_full="$(git describe --tags --abbrev=0)"
if [ ! $? -eq 0 ]; then
    exit 1
fi

current_prefix=
if [[ "$current_full" =~ '/' ]]; then
    current_prefix=${current_full%/*}/
fi

current_git=
if [[ "$current_full" =~ '+git' ]]; then
    current_git=${current_full#*+git}
fi

current_release=
if [[ "$current_full" =~ '-' ]]; then
    current_release=${current_full#*-}
fi

current=${current_full#$current_prefix}
current=${current%+git$current_git}

if [[ "$current" =~ '.' ]]; then
    current_major=$(echo "$current" | cut -d- -f1 | cut -d. -f1)
    current_minor=$(echo "$current" | cut -d- -f1 | cut -d. -f2)
    current_micro=$(echo "$current" | cut -d- -f1 | cut -d. -f3)
    current_patch=$(echo "$current" | cut -d- -f1 | cut -d. -f4)
else
    current_major=$(echo "$current" | cut -d- -f1)
fi

parts=$(echo "$current_tag" | grep -o '\.' | wc -l)

if [ -n "$DEBUG" ]; then
    echo "full '$current_full' ($parts) prefix '$current_prefix' major '$current_major' minor '$current_minor' micro '$current_micro' patch '$current_patch' git '$current_git' release '$current_release'"
fi

while [ $# -gt 0 ]; do
    case "$1" in
        -1|--major)
            ((++current_major))
            if [ -n "$current_minor" ]; then
                current_minor=0
            fi
            if [ -n "$current_micro" ]; then
                current_micro=0
            fi
            if [ -n "$current_git" ]; then
                current_git=1
            fi
            if [ -n "$current_release" ]; then
                current_release=1
            fi
            current_patch=
            ;;
        -2|--minor)
            ((++current_minor))
            if [ -n "$current_micro" ]; then
                current_micro=0
            fi
            if [ -n "$current_git" ]; then
                current_git=1
            fi
            if [ -n "$current_release" ]; then
                current_release=1
            fi
            current_patch=
            ;;
        -3|--micro)
            ((++current_micro))
            if [ -z "$current_minor" ]; then
                current_minor=0
            fi
            if [ -n "$current_git" ]; then
                current_git=1
            fi
            if [ -n "$current_release" ]; then
                current_release=1
            fi
            current_patch=
            ;;
        -4|--patch)
            if [ -z "$current_patch" ]; then
                current_patch=0
            fi
            ((++current_patch))
            if [ -z "$current_minor" ]; then
                current_minor=0
            fi
            if [ -z "$current_micro" ]; then
                current_micro=0
            fi
            if [ -n "$current_git" ]; then
                current_git=1
            fi
            if [ -n "$current_release" ]; then
                current_release=1
            fi
            ;;
        -r|--release)
            ((++current_release))
            ;;
        -g|--git)
            ((++current_git))
            ;;
        -m|--message)
            shift
            TAG_MSG_MSG="$1"
            TAG_ANNOTATE="-a"
            ;;
        -a|--annotate)
            TAG_ANNOTATE="-a"
            ;;
        -p|--prefix)
            shift
            NEW_PREFIX="$1"
            ;;
    esac
    shift
done

new_tag=$current_prefix
new_tag=$new_tag$current_major
if [ -n "$current_minor" ]; then
    new_tag=$new_tag.$current_minor
fi
if [ -n "$current_micro" ]; then
    new_tag=$new_tag.$current_micro
fi
if [ -n "$current_patch" ]; then
    new_tag=$new_tag.$current_patch
fi
if [ -n "$current_release" ]; then
    new_tag=$new_tag-$current_release
fi
if [ -n "$current_git" ]; then
    new_tag=$new_tag+git$current_git
fi
if [ -n "$NEW_PREFIX" ]; then
    new_tag="$NEW_PREFIX$new_tag"
fi

if [ "$current_full" == "$new_tag" ]; then
    echo "No changes to tag $current_full"
    exit 1
fi

echo "Previous tag: $current_full"
echo "New tag: $new_tag"
if [ -n "$TAG_ANNOTATE" ]; then
    echo "Annotated."
fi
if [ -n "$TAG_MSG_MSG" ]; then
    echo "Message: $TAG_MSG_MSG"
fi

echo -n "Create? [Y/n]"
read ask
if [[ "$ask" == "n" || "$ask" == "N" ]]; then
    exit 0
fi

if [ -z "$TAG_MSG_MSG" ]; then
    git tag $TAG_ANNOTATE "$new_tag"
else
    git tag $TAG_ANNOTATE -m "$TAG_MSG_MSG" "$new_tag"
fi
